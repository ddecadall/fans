#include <assert.h>
#include <fuzzer/dependency_solver.h>
#include <fuzzer/types/array_type.h>

#define MAX_ARRAY_SIZE 65537
void ArrayType::generateRaw(vector<uint8_t> *rawData) {
  varSize = parcelReaderWriter->getVarSize(variable);
  assert((int)varSize != -1);
  uint32_t itemIdx = parcelReaderWriter->getVarIdx(varName) + 1;
  Json::Value item = parcelReaderWriter->variable[itemIdx];
  for (uint32_t i = 0; i < varSize; ++i) {
    FUZZER_LOGD("Current idx %u.", i);
    // check dependency
    if (item["dependency"].size() > 0) {
      FUZZER_LOGE("TODO: implement array dependency inside raw structure.");
      exit(0);
    } else {
      parcelReaderWriter->readWriteItem(itemIdx);
    }
  }
}

void ArrayType::generate() {
  if (varName == "uuid") {
    // BnCrypto, BnDrm, BnMediaPlayer
    // Copied from
    // frameworks/av/drm/mediadrm/plugins/clearkey/common/ClearKeyUUID.cpp.
    // Some discussion about crypto scheme uuid:
    // https://stackoverflow.com/questions/16369818/how-to-get-crypto-scheme-uuid.

    // Please add UUID according to your device. You might could find the
    // supported Crypto uuid of your device from the log generated by logcat.
    /*
    CryptoHal: found drm@1.0 ICryptoFactory clearkey
    CryptoHal: found drm@1.0 ICryptoFactory default
    CryptoHal: found drm@1.0 ICryptoFactory widevine
    CryptoHal: found drm@1.1 ICryptoFactory clearkey
    CryptoHal: found drm@1.1 ICryptoFactory widevine */
    static const uint8_t possibleUUID[3][16] = {
        {0x10, 0x77, 0xEF, 0xEC, 0xC0, 0xB2, 0x4D, 0x02, 0xAC, 0xE3, 0x3C, 0x1E,
         0x52, 0xE2, 0xFB, 0x4B}, // kCommonPsshBoxUUID
        {0xE2, 0x71, 0x9D, 0x58, 0xA9, 0x85, 0xB3, 0xC9, 0x78, 0x1A, 0xB0, 0x30,
         0xAF, 0x78, 0xD3, 0x0E}, // kClearKeyUUID, to be used in mpd
                                  // to specify drm scheme for players
        {0xed, 0xef, 0x8b, 0xa9, 0x79, 0xd6, 0x4a, 0xce, 0xa3, 0xc8, 0x27, 0xdc,
         0xd5, 0x1d, 0x21, 0xed} // Widevine
    };
    uint32_t idx = randomUInt64(0, 3 - 1);
    FUZZER_LOGD("UUID idx: %u", idx);
    parcelReaderWriter->data->write(possibleUUID[idx],
                                    sizeof(possibleUUID[idx]));
  } else {
    FUZZER_LOGD("Determine the array size.");
    if (varType.find("vector<") != string::npos ||
        varType.find("Vector<") != string::npos) {
      if (varName == "desiredPresentTimesNano" ||
          varName == "actualPresentTimesNano" ||
          varName == "frameReadyTimesNano") {
        varSize = parcelReaderWriter->getVarValue(varName);
        // here we do not need to write size to the data parcel.
      } else {
        if (IntType<uint32_t>::nOutOf(7, 10)) {
          if (varType.find("in_mac") != string::npos) {
            // mac addr
            varSize = 6;
          } else if (varType.find("in_params") != string::npos) {
            varSize = 4;
          } else if (varName == "in_tlsFingerprints") {
            varSize = 0;
          } else {
            varSize = (uint32_t)IntType<uint32_t>::generateSize();
            // if (varSize >= 100) {
            //   varSize = 100;
            // }
          }
        } else {
          varSize = (uint32_t)IntType<uint32_t>::generateSize();
          // if (varSize >= 100) {
          //   varSize = 100;
          // }
        }
        parcelReaderWriter->data->writeUint32(varSize);
      }
    } else if (varType.find("[") != string::npos) {
      varSize = parcelReaderWriter->getVarSize(variable);
    } else if (varType.find("*") != string::npos) {
      varSize = parcelReaderWriter->getVarSize(variable);
    } else {
      FUZZER_LOGE("Unexpected array type %s meeted.", varType.c_str());
      exit(0);
    }
    FUZZER_LOGD("Array size is %u.", varSize);

    FUZZER_LOGD("Start dealing with array type.");
    if (varType.find("vector<int8_t>") != string::npos ||
        varType.find("vector<char>") != string::npos ||
        varType.find("vector<unsigned char>") != string::npos ||
        varType.find("vector<uint8_t>") != string::npos ||
        varType.find("Vector<unsigned char>") != string::npos ||
        varType.find("uint8_t [") != string::npos ||
        varType.find("int8_t [") != string::npos ||
        varType.find("char [") != string::npos || varType == "void *" ||
        varType.find("char *") != string::npos) {
      // this is special..
      vector<int8_t> tmp;
      for (uint32_t i = 0; i < varSize && i < MAX_ARRAY_SIZE; ++i) {
        tmp.push_back((int8_t)randomUInt64(0, 255));
      }
      if (varSize >= MAX_ARRAY_SIZE) {
        varSize = MAX_ARRAY_SIZE;
      }
      parcelReaderWriter->data->write(tmp.data(), varSize);
    } else {
      uint32_t itemIdx = parcelReaderWriter->getVarIdx(varName) + 1;
      Json::Value item = parcelReaderWriter->variable[itemIdx];
      for (uint32_t i = 0; i < varSize && i < MAX_ARRAY_SIZE; ++i) {
        FUZZER_LOGI("Generate array item idx: %u, name: %s.", i,
                    item["name"].asCString());
        // check dependency
        if (item["dependency"].size() > 0) {
          DependencySolver solver(parcelReaderWriter->data, COMMON_DEPENDENCY,
                                  item["dependency"]);
          if (solver.canUseDependency()) {
            solver.solve();
          } else {
            FUZZER_LOGI("Generate array item manually.");
            parcelReaderWriter->readWriteItem(itemIdx);
          }
        } else {
          FUZZER_LOGI("Generate array item manually.");
          parcelReaderWriter->readWriteItem(itemIdx);
        }
      }
    }
  }
}
void ArrayType::read() {
  FUZZER_LOGD("Start dealing with array type..");
  if (varType.find("vector<unsigned char>") != string::npos ||
      varType.find("Vector<unsigned char>") != string::npos) {
    vector<int8_t> tmp;
    parcelReaderWriter->reply->readByteVector(&tmp);
    FUZZER_LOGD("Array size: %lu.", tmp.size());
    string result = "";
    for (auto i : tmp) {
      result += to_string(i) + " ";
    }
    FUZZER_LOGD("Array content: %s.", result.c_str());
    if (parcelReaderWriter->isDependency) {
      // write date to targetparcel
      parcelReaderWriter->targetParcel->write(tmp.data(), tmp.size());
    }
  } else if (varType.find("int8_t [") != string::npos ||
             varType.find("char [") != string::npos || varType == "void *" ||
             varType.find("char *") != string::npos) {
    vector<int8_t> tmp;
    varSize = parcelReaderWriter->getVarSize(variable);
    FUZZER_LOGD("Array size: %u.", varSize);
    if (varSize > MAX_ARRAY_SIZE) {
      varSize = MAX_ARRAY_SIZE;
    }
    tmp.resize(varSize);
    parcelReaderWriter->reply->read(tmp.data(), varSize);
    if (parcelReaderWriter->isDependency) {
      // write date to targetparcel
      parcelReaderWriter->targetParcel->write(tmp.data(), tmp.size());
    }
  } else {
    if (varType.find("[") != string::npos ||
        varType.find("*") != string::npos) {
      varSize = parcelReaderWriter->getVarSize(variable);
    } else if (varType.find("vector<") != string::npos ||
               varType.find("Vector<") != string::npos) {
      if (varName == "desiredPresentTimesNano" ||
          varName == "actualPresentTimesNano" ||
          varName == "frameReadyTimesNano") {
        varSize = parcelReaderWriter->getVarValue(varName);
        // here we do not need to read size from the data parcel.
      } else {
        varSize = parcelReaderWriter->reply->readUint32();
      }
    } else {
      FUZZER_LOGE("Unexpected array type %s meeted.", varType.c_str());
      exit(0);
    }
    FUZZER_LOGD("Array size: %u.", varSize);
    uint32_t dependencyIdx = UINT32_MAX;
    if (parcelReaderWriter->isDependency) {
      if (varSize >= MAX_ARRAY_SIZE) {
        dependencyIdx = randomUInt64(0, MAX_ARRAY_SIZE - 1);
      } else {
        dependencyIdx = randomUInt64(0, varSize - 1);
      }
      FUZZER_LOGD("Ramdom choose idx %d in array as dependency item.",
                  dependencyIdx);
      FUZZER_LOGD("Reset dependency status in order not to read other items.");
      parcelReaderWriter->isDependency = false;
    }
    uint32_t itemIdx = parcelReaderWriter->getVarIdx(varName) + 1;
    Json::Value item = parcelReaderWriter->variable[itemIdx];
    if (item["name"] != varName + "::item") {
      FUZZER_LOGE("The following name is %s, which is not a array item of %s.",
                  item["name"].asCString(), varName.c_str());
      exit(0);
    }
    spaceNum += 2;
    for (uint32_t i = 0; i < varSize && i < MAX_ARRAY_SIZE; ++i) {
      FUZZER_LOGD("Current array item idx: %u.", i);
      spaceNum += 2;
      if (i == dependencyIdx) {
        FUZZER_LOGD(
            "This the target dependency array item. Recover depdendency.");
        parcelReaderWriter->isDependency = true;
      }
      parcelReaderWriter->readWriteItem(itemIdx);
      if (parcelReaderWriter->isDependency) {
        // TODO: maybe we should consider a better way to handle this situation.
        FUZZER_LOGD("We have already read the dependency array item, so we can "
                    "return.");
        spaceNum -= 2;
        goto out;
      }
      spaceNum -= 2;
    }
  out:
    spaceNum -= 2;
  }
}
